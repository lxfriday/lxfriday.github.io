---
title: 前端面试必会 | 一文读懂 JavaScript 中的闭包
comments: true
top: false
date: 2019-12-09 23:59:00
img: https://qiniu1.lxfriday.xyz/blog/image_20191209211831.png
categories: javascript
tags:
  - 闭包
  - 词法环境
  - 执行上下文
---

<section id="nice" style="padding: 10px; line-height: 1.6; word-spacing: 0px; word-break: break-word; word-wrap: break-word; text-align: left; font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, 'PingFang SC', Cambria, Cochin, Georgia, Times, 'Times New Roman', serif; font-size: 15px; letter-spacing: 0.05em; color: #595959;"><figure style="margin: 0; margin-top: 10px; margin-bottom: 10px;"><img src="https://qiniu1.lxfriday.xyz/blog/image_20191209211831.png" alt style="display: block; margin: 0 auto; width: 100%;"></figure>
<blockquote style="display: block; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; margin: 10px 5px; border-left: 3px solid #9654B5; border-right: 1px solid #9654B5; color: #616161; quotes: none; background: #FBF9FD;">
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0px; color: black; line-height: 26px;">本文翻译自 <a href="https://blog.bitsrc.io/a-beginners-guide-to-closures-in-javascript-97d372284dda" style="text-decoration: none; word-wrap: break-word; font-weight: bold; color: #773098; border-bottom: 1px solid #773098;">https://blog.bitsrc.io/a-beginners-guide-to-closures-in-javascript-97d372284dda</a>，作者 Sukhjinder Arora，内容有部分修改，标题有修改。</p>
</blockquote>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 1em 4px;">闭包是每个 JavaScript 程序员都应该知道并且掌握的基础概念。然而，这个概念使很多 JavaScript 新手感到困惑。</p>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 1em 4px;">对闭包有适当的了解将有助于您编写更好，更有效和干净的代码。反过来，它将帮助您成为更好的 JavaScript 开发人员。</p>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 1em 4px;">因此，在本文中，我将尝试解释闭包的原理以及它们在 JavaScript 中的实际工作方式。</p>
<h1 style="margin-top: 40px; margin-bottom: 20px; margin: 1.2em 0 1em; padding: 0; font-weight: 900; color: #773098; font-size: 25px;"><span>闭包是什么</span></h1>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 1em 4px;">下图就是闭包：</p>
<figure style="margin: 0; margin-top: 10px; margin-bottom: 10px;"><img src="https://qiniu1.lxfriday.xyz/blog/image_20191209235601.png" alt="闭包" style="display: block; margin: 0 auto; width: 100%;"><figcaption style="margin-top: 5px; text-align: center; color: #888; font-size: 14px;">闭包</figcaption></figure>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 1em 4px;"><strong style="color: #000000; font-weight: bold;">闭包是即使外部函数返回之后也可以访问其外部函数作用域的函数</strong>。这意味着闭包即使外层函数执行完成了也可以记住并访问外层函数的变量和参数。要注意，在图示中由于没有使用 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #333333;">age</code> 变量，所以打印出的闭包中没有它。</p>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 1em 4px;">在深入探讨闭包之前，让我们首先了解词法作用域。</p>
<h2 style="margin-top: 40px; min-height: 32px; line-height: 28px; border-bottom: solid 1px #000000; color: #773098; display: inline-block; border-bottom-width: 1px; border-bottom-style: solid; border-color: #773098; padding-top: 5px; padding-right: 0.5em; padding-left: 0.5em; margin-bottom: -3px; font-size: 15px; margin: 1em auto; padding: 0.5em 0 0.2em 0; text-align: center; width: 85%; font-weight: bold; display: flex; flex-direction: column; justify-content: center;"><span>词法作用域是什么？</span></h2>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 1em 4px;">JavaScript 中的<strong style="color: #000000; font-weight: bold;">词法作用域</strong>或<strong style="color: #000000; font-weight: bold;">静态作用域</strong>是指变量、函数和对象根据其在源代码中的实际位置而产生的可访问性。例如：</p>
<pre class="custom" style="margin-top: 10px; margin-bottom: 10px;"><code class="hljs" style="overflow-x: auto; padding: 16px; background: #272822; color: #ddd; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; display: -webkit-box !important;"><span class="hljs-keyword" style="color: #f92672; font-weight: bold; line-height: 26px;">let</span> a = <span class="hljs-string" style="color: #a6e22e; line-height: 26px;">'global'</span>;
<span class="hljs-function" style="line-height: 26px;"><span class="hljs-keyword" style="color: #f92672; font-weight: bold; line-height: 26px;">function</span> <span class="hljs-title" style="color: #a6e22e; font-weight: bold; line-height: 26px;">outer</span>(<span class="hljs-params" style="line-height: 26px;"></span>) </span>{
  <span class="hljs-keyword" style="color: #f92672; font-weight: bold; line-height: 26px;">let</span> b = <span class="hljs-string" style="color: #a6e22e; line-height: 26px;">'outer'</span>;
  <span class="hljs-function" style="line-height: 26px;"><span class="hljs-keyword" style="color: #f92672; font-weight: bold; line-height: 26px;">function</span> <span class="hljs-title" style="color: #a6e22e; font-weight: bold; line-height: 26px;">inner</span>(<span class="hljs-params" style="line-height: 26px;"></span>) </span>{
    <span class="hljs-keyword" style="color: #f92672; font-weight: bold; line-height: 26px;">let</span> c = <span class="hljs-string" style="color: #a6e22e; line-height: 26px;">'inner'</span>
    <span class="hljs-built_in" style="color: #a6e22e; line-height: 26px;">console</span>.log(c);   <span class="hljs-comment" style="color: #75715e; line-height: 26px;">// prints 'inner'</span>
    <span class="hljs-built_in" style="color: #a6e22e; line-height: 26px;">console</span>.log(b);   <span class="hljs-comment" style="color: #75715e; line-height: 26px;">// prints 'outer'</span>
    <span class="hljs-built_in" style="color: #a6e22e; line-height: 26px;">console</span>.log(a);   <span class="hljs-comment" style="color: #75715e; line-height: 26px;">// prints 'global'</span>
  }
  <span class="hljs-built_in" style="color: #a6e22e; line-height: 26px;">console</span>.log(a);     <span class="hljs-comment" style="color: #75715e; line-height: 26px;">// prints 'global'</span>
  <span class="hljs-built_in" style="color: #a6e22e; line-height: 26px;">console</span>.log(b);     <span class="hljs-comment" style="color: #75715e; line-height: 26px;">// prints 'outer'</span>
  inner();
}
outer();
<span class="hljs-built_in" style="color: #a6e22e; line-height: 26px;">console</span>.log(a);         <span class="hljs-comment" style="color: #75715e; line-height: 26px;">// prints 'global'</span>
</code></pre>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 1em 4px;">在这里，<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #333333;">inner</code> 函数可以访问在其自己的作用域、<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #333333;">outer</code> 函数的作用域和全局作用域中定义的变量。而 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #333333;">outer</code> 函数可以访问在它自己的作用域和全局作用域内定义的变量。</p>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 1em 4px;">因此，上述代码的作用域链如下所示：</p>
<pre class="custom" style="margin-top: 10px; margin-bottom: 10px;"><code class="hljs" style="overflow-x: auto; padding: 16px; background: #272822; color: #ddd; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; display: -webkit-box !important;">Global {
  outer {
    inner
  }
}
</code></pre>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 1em 4px;">注意，<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #333333;">inner</code> 函数被 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #333333;">outer</code> 函数的词法作用域所包围，而 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #333333;">outer</code> 函数的词法作用域又被全局作用域所围绕。这就是为什么 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #333333;">inner</code> 函数可以访问在 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #333333;">outer</code> 函数和全局作用域中定义的变量的原因。</p>
<h1 style="margin-top: 40px; margin-bottom: 20px; margin: 1.2em 0 1em; padding: 0; font-weight: 900; color: #773098; font-size: 25px;"><span>闭包的演示</span></h1>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 1em 4px;">在深入探讨闭包的工作原理之前，让我们看一下闭包的一些实际示例。</p>
<h2 style="margin-top: 40px; min-height: 32px; line-height: 28px; border-bottom: solid 1px #000000; color: #773098; display: inline-block; border-bottom-width: 1px; border-bottom-style: solid; border-color: #773098; padding-top: 5px; padding-right: 0.5em; padding-left: 0.5em; margin-bottom: -3px; font-size: 15px; margin: 1em auto; padding: 0.5em 0 0.2em 0; text-align: center; width: 85%; font-weight: bold; display: flex; flex-direction: column; justify-content: center;"><span>示例1</span></h2>
<pre class="custom" style="margin-top: 10px; margin-bottom: 10px;"><code class="hljs" style="overflow-x: auto; padding: 16px; background: #272822; color: #ddd; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; display: -webkit-box !important;"><span class="hljs-function" style="line-height: 26px;"><span class="hljs-keyword" style="color: #f92672; font-weight: bold; line-height: 26px;">function</span> <span class="hljs-title" style="color: #a6e22e; font-weight: bold; line-height: 26px;">person</span>(<span class="hljs-params" style="line-height: 26px;"></span>) </span>{
  <span class="hljs-keyword" style="color: #f92672; font-weight: bold; line-height: 26px;">let</span> name = <span class="hljs-string" style="color: #a6e22e; line-height: 26px;">'Peter'</span>;
  
  <span class="hljs-keyword" style="color: #f92672; font-weight: bold; line-height: 26px;">return</span> <span class="hljs-function" style="line-height: 26px;"><span class="hljs-keyword" style="color: #f92672; font-weight: bold; line-height: 26px;">function</span> <span class="hljs-title" style="color: #a6e22e; font-weight: bold; line-height: 26px;">displayName</span>(<span class="hljs-params" style="line-height: 26px;"></span>) </span>{
    <span class="hljs-built_in" style="color: #a6e22e; line-height: 26px;">console</span>.log(name);
  };
}
<span class="hljs-keyword" style="color: #f92672; font-weight: bold; line-height: 26px;">let</span> peter = person();
peter(); <span class="hljs-comment" style="color: #75715e; line-height: 26px;">// prints 'Peter'</span>
</code></pre>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 1em 4px;">在此代码中，我们正在调用 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #333333;">person</code> 函数，该函数返回内部函数 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #333333;">displayName</code> 并将该内部函数存储在 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #333333;">peter</code> 变量中。当我们调用 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #333333;">peter</code> 函数（实际上是在引用 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #333333;">displayName</code> 函数）时，名称 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #333333;">Peter</code> 被打印到控制台上。</p>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 1em 4px;">但是我们没有在 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #333333;">displayName</code> 函数中声明 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #333333;">name</code> 变量，因此即使外层函数返回后，该函数也可以以某种方式访问其外部函数的变量 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #333333;">person</code>。因此，<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #333333;">displayName</code> 函数实际上产生了一个闭包。</p>
<h2 style="margin-top: 40px; min-height: 32px; line-height: 28px; border-bottom: solid 1px #000000; color: #773098; display: inline-block; border-bottom-width: 1px; border-bottom-style: solid; border-color: #773098; padding-top: 5px; padding-right: 0.5em; padding-left: 0.5em; margin-bottom: -3px; font-size: 15px; margin: 1em auto; padding: 0.5em 0 0.2em 0; text-align: center; width: 85%; font-weight: bold; display: flex; flex-direction: column; justify-content: center;"><span>示例2</span></h2>
<pre class="custom" style="margin-top: 10px; margin-bottom: 10px;"><code class="hljs" style="overflow-x: auto; padding: 16px; background: #272822; color: #ddd; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; display: -webkit-box !important;"><span class="hljs-function" style="line-height: 26px;"><span class="hljs-keyword" style="color: #f92672; font-weight: bold; line-height: 26px;">function</span> <span class="hljs-title" style="color: #a6e22e; font-weight: bold; line-height: 26px;">getCounter</span>(<span class="hljs-params" style="line-height: 26px;"></span>) </span>{
  <span class="hljs-keyword" style="color: #f92672; font-weight: bold; line-height: 26px;">let</span> counter = <span class="hljs-number" style="line-height: 26px;">0</span>;
  <span class="hljs-keyword" style="color: #f92672; font-weight: bold; line-height: 26px;">return</span> <span class="hljs-function" style="line-height: 26px;"><span class="hljs-keyword" style="color: #f92672; font-weight: bold; line-height: 26px;">function</span>(<span class="hljs-params" style="line-height: 26px;"></span>) </span>{
    <span class="hljs-keyword" style="color: #f92672; font-weight: bold; line-height: 26px;">return</span> counter++;
  }
}
<span class="hljs-keyword" style="color: #f92672; font-weight: bold; line-height: 26px;">let</span> count = getCounter();
<span class="hljs-built_in" style="color: #a6e22e; line-height: 26px;">console</span>.log(count());  <span class="hljs-comment" style="color: #75715e; line-height: 26px;">// 0</span>
<span class="hljs-built_in" style="color: #a6e22e; line-height: 26px;">console</span>.log(count());  <span class="hljs-comment" style="color: #75715e; line-height: 26px;">// 1</span>
<span class="hljs-built_in" style="color: #a6e22e; line-height: 26px;">console</span>.log(count());  <span class="hljs-comment" style="color: #75715e; line-height: 26px;">// 2</span>
</code></pre>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 1em 4px;">同样，我们将 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #333333;">getCounter</code> 函数返回的匿名内部函数赋值给 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #333333;">count</code> 变量。<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #333333;">count</code> 函数现在就成为了一个闭包，即使 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #333333;">getCounter()</code> 执行完毕，它依然可以访问 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #333333;">getCounter</code> 函数内部的 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #333333;">counter</code> 变量。</p>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 1em 4px;">但是请注意，每次 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #333333;">count</code> 执行的时候 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #333333;">counter</code> 的值并不会重置为 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #333333;">0</code> 。</p>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 1em 4px;">这是因为，每次调用 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #333333;">count()</code>，将会为该函数创建一个新的作用域，但是这里只给 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #333333;">getCounter</code> 创建了一个作用域，又因为 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #333333;">counter</code> 变量是定义在 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #333333;">getCounter</code> 函数作用域内部的，所以它将在每次 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #333333;">count</code> 调用的时候自增而不是被重置。</p>
<h1 style="margin-top: 40px; margin-bottom: 20px; margin: 1.2em 0 1em; padding: 0; font-weight: 900; color: #773098; font-size: 25px;"><span>闭包是如何工作的</span></h1>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 1em 4px;">到目前为止，我们已经讨论了什么是闭包及其实际示例。现在，让我们了解闭包在 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #333333;">JavaScript</code> 中如何真正起作用。</p>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 1em 4px;">要真正了解闭包在 JavaScript 中是如何工作的，我们必须了解 JavaScript 中两个最重要的概念，即 1）<strong style="color: #000000; font-weight: bold;">执行上下文</strong>和 2）<strong style="color: #000000; font-weight: bold;">词法环境</strong>。</p>
<h2 style="margin-top: 40px; min-height: 32px; line-height: 28px; border-bottom: solid 1px #000000; color: #773098; display: inline-block; border-bottom-width: 1px; border-bottom-style: solid; border-color: #773098; padding-top: 5px; padding-right: 0.5em; padding-left: 0.5em; margin-bottom: -3px; font-size: 15px; margin: 1em auto; padding: 0.5em 0 0.2em 0; text-align: center; width: 85%; font-weight: bold; display: flex; flex-direction: column; justify-content: center;"><span>执行上下文</span></h2>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 1em 4px;">执行上下文是一个抽象的环境，JavaScript 代码在其中执行。当全局代码执行时，它将在全局执行上下文中执行，而函数代码将在函数执行上下文中执行。</p>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 1em 4px;"><strong style="color: #000000; font-weight: bold;">每次只能有一个执行上下文处于运行状态，因为 JavaScript 是单线程语言，它由执行栈或者调用栈来管理。</strong></p>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 1em 4px;">执行堆栈是具有 LIFO（后进先出）结构的堆栈，只能从堆栈顶部添加或删除项目。</p>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 1em 4px;">当前正在运行的执行上下文将始终位于堆栈的顶部，并且当当前正在运行的函数完成时，其执行上下文将从堆栈中弹出，并且指针将指向堆栈中位于其下方的执行上下文。</p>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 1em 4px;">让我们看一下代码片段，以更好地理解执行上下文和堆栈：</p>
<figure style="margin: 0; margin-top: 10px; margin-bottom: 10px;"><img src="https://qiniu1.lxfriday.xyz/blog/image_20191209215910.png" alt="执行上下文示例" style="display: block; margin: 0 auto; width: 100%;"><figcaption style="margin-top: 5px; text-align: center; color: #888; font-size: 14px;">执行上下文示例</figcaption></figure>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 1em 4px;">当执行此代码时，JavaScript 引擎会创建一个全局执行上下文来执行该全局代码，并且当它遇到 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #333333;">first()</code> 函数调用时，它将为该函数创建一个新的执行上下文并将其推入执行堆栈的顶部。</p>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 1em 4px;">因此，以上代码的执行堆栈如下所示：</p>
<figure style="margin: 0; margin-top: 10px; margin-bottom: 10px;"><img src="https://qiniu1.lxfriday.xyz/blog/image_20191209220019.png" alt="执行栈" style="display: block; margin: 0 auto; width: 100%;"><figcaption style="margin-top: 5px; text-align: center; color: #888; font-size: 14px;">执行栈</figcaption></figure>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 1em 4px;">当 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #333333;">first()</code> 函数结束，它的执行堆栈被从栈中删除，并且指针达到到其下方的执行上下文，即，全局执行上下文。因此，将执行全局范围内的剩余代码。</p>
<h2 style="margin-top: 40px; min-height: 32px; line-height: 28px; border-bottom: solid 1px #000000; color: #773098; display: inline-block; border-bottom-width: 1px; border-bottom-style: solid; border-color: #773098; padding-top: 5px; padding-right: 0.5em; padding-left: 0.5em; margin-bottom: -3px; font-size: 15px; margin: 1em auto; padding: 0.5em 0 0.2em 0; text-align: center; width: 85%; font-weight: bold; display: flex; flex-direction: column; justify-content: center;"><span>词法环境</span></h2>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 1em 4px;">每当 JavaScript 引擎创建执行上下文来执行该函数或全局代码时，它就会创建一个新的词法环境来存储在该函数执行期间该函数中定义的变量。</p>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 1em 4px;"><strong style="color: #000000; font-weight: bold;">词法环境是一个存储标识符和变量映射关系的数据结构。标识符指的是变量或者函数的名字，变量指的是实际的对象，包括函数或者原始值。</strong></p>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 1em 4px;">词法环境包括三个部分：(1) 环境记录；(2)<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #333333;">outer</code> 外部环境的指向；(3)<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #333333;">this</code></p>
<ol style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500; margin: 10px 0;">环境记录是存储变量和函数声明的地方；</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500; margin: 10px 0;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #333333;">outer</code>，外部环境的指向表示它可以访问外层（父层）的词法环境。它是理解闭包原理的关键。</section></li></ol>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 1em 4px;">词法环境的结构如下：</p>
<pre class="custom" style="margin-top: 10px; margin-bottom: 10px;"><code class="hljs" style="overflow-x: auto; padding: 16px; background: #272822; color: #ddd; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; display: -webkit-box !important;">lexicalEnvironment = {
  <span class="hljs-attr" style="line-height: 26px;">EnvironmentRecord</span>: {
    &lt;identifier&gt; : &lt;value&gt;,
    &lt;identifier&gt; : &lt;value&gt;
  }
  outer: &lt;Reference to the parent lexical environment&gt;
  ThisBinding: &lt;Global Object&gt;
}
</code></pre>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 1em 4px;">现在分析下面的代码。</p>
<pre class="custom" style="margin-top: 10px; margin-bottom: 10px;"><code class="hljs" style="overflow-x: auto; padding: 16px; background: #272822; color: #ddd; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; display: -webkit-box !important;"><span class="hljs-keyword" style="color: #f92672; font-weight: bold; line-height: 26px;">let</span> a = <span class="hljs-string" style="color: #a6e22e; line-height: 26px;">'Hello World!'</span>;
<span class="hljs-function" style="line-height: 26px;"><span class="hljs-keyword" style="color: #f92672; font-weight: bold; line-height: 26px;">function</span> <span class="hljs-title" style="color: #a6e22e; font-weight: bold; line-height: 26px;">first</span>(<span class="hljs-params" style="line-height: 26px;"></span>) </span>{
  <span class="hljs-keyword" style="color: #f92672; font-weight: bold; line-height: 26px;">let</span> b = <span class="hljs-number" style="line-height: 26px;">25</span>;  
  <span class="hljs-built_in" style="color: #a6e22e; line-height: 26px;">console</span>.log(<span class="hljs-string" style="color: #a6e22e; line-height: 26px;">'Inside first function'</span>);
}
first();
<span class="hljs-built_in" style="color: #a6e22e; line-height: 26px;">console</span>.log(<span class="hljs-string" style="color: #a6e22e; line-height: 26px;">'Inside global execution context'</span>);
</code></pre>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 1em 4px;">当 JavaScript 引擎创建用来执行全局代码的全局执行上下文时，它就会创建一个新的词法环境来存储在全局范围内定义的变量和函数。因此，全局作用域的词法环境将如下所示：</p>
<pre class="custom" style="margin-top: 10px; margin-bottom: 10px;"><code class="hljs" style="overflow-x: auto; padding: 16px; background: #272822; color: #ddd; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; display: -webkit-box !important;">globalLexicalEnvironment = {
  <span class="hljs-attr" style="line-height: 26px;">EnvironmentRecord</span>: {
      <span class="hljs-attr" style="line-height: 26px;">a</span>     : <span class="hljs-string" style="color: #a6e22e; line-height: 26px;">'Hello World!'</span>,
      <span class="hljs-attr" style="line-height: 26px;">first</span> : &lt;reference to function object &gt;
  }
  outer: null
  ThisBinding: &lt;Global Object&gt;
}
</code></pre>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 1em 4px;">此处将外部词法环境设置为 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #333333;">null</code> 是因为全局作用域没有外部词法环境。</p>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 1em 4px;">当引擎为 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #333333;">first()</code> 函数创建执行上下文时，它还会创建一个词法环境来存储在函数执行期间在该函数中定义的变量。因此，该函数的词法环境如下所示：</p>
<pre class="custom" style="margin-top: 10px; margin-bottom: 10px;"><code class="hljs" style="overflow-x: auto; padding: 16px; background: #272822; color: #ddd; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; display: -webkit-box !important;">functionLexicalEnvironment = {
  <span class="hljs-attr" style="line-height: 26px;">EnvironmentRecord</span>: {
      <span class="hljs-attr" style="line-height: 26px;">b</span>    : <span class="hljs-number" style="line-height: 26px;">25</span>,
  }
  outer: &lt;globalLexicalEnvironment&gt;
  ThisBinding: &lt;Global Object&gt;
}
</code></pre>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 1em 4px;">函数的外部词法环境被设置为全局词法环境，因为函数在源代码中被全局作用域所包围。</p>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 1em 4px;">注意，函数完成后，其执行上下文将从堆栈中删除，但是它的词法环境可能会也可能不会从内存中删除，具体取决于该词法环境是否被其它词法环境引用（取决于是否存在闭包）。</p>
<h1 style="margin-top: 40px; margin-bottom: 20px; margin: 1.2em 0 1em; padding: 0; font-weight: 900; color: #773098; font-size: 25px;"><span>详细的闭包示例</span></h1>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 1em 4px;">现在我们了解了执行上下文和词法环境，让我们回到闭包。</p>
<h2 style="margin-top: 40px; min-height: 32px; line-height: 28px; border-bottom: solid 1px #000000; color: #773098; display: inline-block; border-bottom-width: 1px; border-bottom-style: solid; border-color: #773098; padding-top: 5px; padding-right: 0.5em; padding-left: 0.5em; margin-bottom: -3px; font-size: 15px; margin: 1em auto; padding: 0.5em 0 0.2em 0; text-align: center; width: 85%; font-weight: bold; display: flex; flex-direction: column; justify-content: center;"><span>示例1</span></h2>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 1em 4px;">看下面的代码：</p>
<pre class="custom" style="margin-top: 10px; margin-bottom: 10px;"><code class="hljs" style="overflow-x: auto; padding: 16px; background: #272822; color: #ddd; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; display: -webkit-box !important;"><span class="hljs-function" style="line-height: 26px;"><span class="hljs-keyword" style="color: #f92672; font-weight: bold; line-height: 26px;">function</span> <span class="hljs-title" style="color: #a6e22e; font-weight: bold; line-height: 26px;">person</span>(<span class="hljs-params" style="line-height: 26px;"></span>) </span>{
  <span class="hljs-keyword" style="color: #f92672; font-weight: bold; line-height: 26px;">let</span> name = <span class="hljs-string" style="color: #a6e22e; line-height: 26px;">'Peter'</span>;
  
  <span class="hljs-keyword" style="color: #f92672; font-weight: bold; line-height: 26px;">return</span> <span class="hljs-function" style="line-height: 26px;"><span class="hljs-keyword" style="color: #f92672; font-weight: bold; line-height: 26px;">function</span> <span class="hljs-title" style="color: #a6e22e; font-weight: bold; line-height: 26px;">displayName</span>(<span class="hljs-params" style="line-height: 26px;"></span>) </span>{
    <span class="hljs-built_in" style="color: #a6e22e; line-height: 26px;">console</span>.log(name);
  };
}
<span class="hljs-keyword" style="color: #f92672; font-weight: bold; line-height: 26px;">let</span> peter = person();
peter(); <span class="hljs-comment" style="color: #75715e; line-height: 26px;">// prints 'Peter'</span>
</code></pre>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 1em 4px;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #333333;">person</code> 函数执行时，JavaScript 引擎会为该函数创建新的执行上下文和词法环境。该函数执行完毕之后，它会返回 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #333333;">displayName</code> 函数并把它赋值给 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #333333;">peter</code> 变量。</p>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 1em 4px;">因此其词法环境如下所示：</p>
<pre class="custom" style="margin-top: 10px; margin-bottom: 10px;"><code class="hljs" style="overflow-x: auto; padding: 16px; background: #272822; color: #ddd; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; display: -webkit-box !important;">personLexicalEnvironment = {
  <span class="hljs-attr" style="line-height: 26px;">EnvironmentRecord</span>: {
    <span class="hljs-attr" style="line-height: 26px;">name</span> : <span class="hljs-string" style="color: #a6e22e; line-height: 26px;">'Peter'</span>,
    <span class="hljs-attr" style="line-height: 26px;">displayName</span>: &lt;displayName function reference&gt;
  }
  outer: &lt;globalLexicalEnvironment&gt;
  ThisBinding: &lt;Global Object&gt;
}
</code></pre>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 1em 4px;">由于 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #333333;">displayName</code> 函数中没有变量，因此其环境记录将为空。在执行此函数期间，JavaScript 引擎将尝试在此函数的词法环境中查找变量 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #333333;">name</code>。</p>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 1em 4px;">由于 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #333333;">displayName</code> 函数的词法环境中没有变量，因此它将查看外部词法环境，即 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #333333;">person</code> 函数仍在内存中的词法环境。JavaScript 引擎找到该变量并将 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #333333;">name</code> 打印到控制台。</p>
<h2 style="margin-top: 40px; min-height: 32px; line-height: 28px; border-bottom: solid 1px #000000; color: #773098; display: inline-block; border-bottom-width: 1px; border-bottom-style: solid; border-color: #773098; padding-top: 5px; padding-right: 0.5em; padding-left: 0.5em; margin-bottom: -3px; font-size: 15px; margin: 1em auto; padding: 0.5em 0 0.2em 0; text-align: center; width: 85%; font-weight: bold; display: flex; flex-direction: column; justify-content: center;"><span>示例2</span></h2>
<pre class="custom" style="margin-top: 10px; margin-bottom: 10px;"><code class="hljs" style="overflow-x: auto; padding: 16px; background: #272822; color: #ddd; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; display: -webkit-box !important;"><span class="hljs-function" style="line-height: 26px;"><span class="hljs-keyword" style="color: #f92672; font-weight: bold; line-height: 26px;">function</span> <span class="hljs-title" style="color: #a6e22e; font-weight: bold; line-height: 26px;">getCounter</span>(<span class="hljs-params" style="line-height: 26px;"></span>) </span>{
  <span class="hljs-keyword" style="color: #f92672; font-weight: bold; line-height: 26px;">let</span> counter = <span class="hljs-number" style="line-height: 26px;">0</span>;
  <span class="hljs-keyword" style="color: #f92672; font-weight: bold; line-height: 26px;">return</span> <span class="hljs-function" style="line-height: 26px;"><span class="hljs-keyword" style="color: #f92672; font-weight: bold; line-height: 26px;">function</span>(<span class="hljs-params" style="line-height: 26px;"></span>) </span>{
    <span class="hljs-keyword" style="color: #f92672; font-weight: bold; line-height: 26px;">return</span> counter++;
  }
}
<span class="hljs-keyword" style="color: #f92672; font-weight: bold; line-height: 26px;">let</span> count = getCounter();
<span class="hljs-built_in" style="color: #a6e22e; line-height: 26px;">console</span>.log(count());  <span class="hljs-comment" style="color: #75715e; line-height: 26px;">// 0</span>
<span class="hljs-built_in" style="color: #a6e22e; line-height: 26px;">console</span>.log(count());  <span class="hljs-comment" style="color: #75715e; line-height: 26px;">// 1</span>
<span class="hljs-built_in" style="color: #a6e22e; line-height: 26px;">console</span>.log(count());  <span class="hljs-comment" style="color: #75715e; line-height: 26px;">// 2</span>
</code></pre>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 1em 4px;">同样，<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #333333;">getCounter</code> 函数的词法环境如下所示：</p>
<pre class="custom" style="margin-top: 10px; margin-bottom: 10px;"><code class="hljs" style="overflow-x: auto; padding: 16px; background: #272822; color: #ddd; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; display: -webkit-box !important;">getCounterLexicalEnvironment = {
  <span class="hljs-attr" style="line-height: 26px;">EnvironmentRecord</span>: {
    <span class="hljs-attr" style="line-height: 26px;">counter</span>: <span class="hljs-number" style="line-height: 26px;">0</span>,
    &lt;anonymous <span class="hljs-function" style="line-height: 26px;"><span class="hljs-keyword" style="color: #f92672; font-weight: bold; line-height: 26px;">function</span>&gt; : &lt;<span class="hljs-title" style="color: #a6e22e; font-weight: bold; line-height: 26px;">reference</span> <span class="hljs-title" style="color: #a6e22e; font-weight: bold; line-height: 26px;">to</span> <span class="hljs-title" style="color: #a6e22e; font-weight: bold; line-height: 26px;">function</span>&gt;
  }
  <span class="hljs-title" style="color: #a6e22e; font-weight: bold; line-height: 26px;">outer</span>: &lt;<span class="hljs-title" style="color: #a6e22e; font-weight: bold; line-height: 26px;">globalLexicalEnvironment</span>&gt;
}
</span></code></pre>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 1em 4px;">该函数返回一个匿名函数并将其赋值给 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #333333;">count</code> 变量。</p>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 1em 4px;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #333333;">count</code> 执行时，其词法环境将如下所示：</p>
<pre class="custom" style="margin-top: 10px; margin-bottom: 10px;"><code class="hljs" style="overflow-x: auto; padding: 16px; background: #272822; color: #ddd; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; display: -webkit-box !important;">countLexicalEnvironment = {
  <span class="hljs-attr" style="line-height: 26px;">EnvironmentRecord</span>: {
  }
  outer: <span class="xml" style="line-height: 26px;"><span class="hljs-tag" style="color: #f92672; line-height: 26px;">&lt;<span class="hljs-name" style="color: #f92672; line-height: 26px;">getCountLexicalEnvironment</span>&gt;</span>
}
</span></code></pre>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 1em 4px;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #333333;">count</code> 函数执行时时，JavaScript 引擎将在此函数的词法环境中查找 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #333333;">counter</code>。同样，由于其环境记录为空，因此引擎将查找函数的外部词法环境。</p>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 1em 4px;">引擎找到该变量，将其打印到控制台，并将 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #333333;">getCounter</code> 函数词法环境中的变量加1。</p>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 1em 4px;">因此，首次调用 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #333333;">count</code> 函数后 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #333333;">getCounter</code> 函数的词法环境如下所示：</p>
<pre class="custom" style="margin-top: 10px; margin-bottom: 10px;"><code class="hljs" style="overflow-x: auto; padding: 16px; background: #272822; color: #ddd; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch; display: -webkit-box !important;">getCounterLexicalEnvironment = {
  <span class="hljs-attr" style="line-height: 26px;">EnvironmentRecord</span>: {
    <span class="hljs-attr" style="line-height: 26px;">counter</span>: <span class="hljs-number" style="line-height: 26px;">1</span>,
    &lt;anonymous <span class="hljs-function" style="line-height: 26px;"><span class="hljs-keyword" style="color: #f92672; font-weight: bold; line-height: 26px;">function</span>&gt; : &lt;<span class="hljs-title" style="color: #a6e22e; font-weight: bold; line-height: 26px;">reference</span> <span class="hljs-title" style="color: #a6e22e; font-weight: bold; line-height: 26px;">to</span> <span class="hljs-title" style="color: #a6e22e; font-weight: bold; line-height: 26px;">function</span>&gt;
  }
  <span class="hljs-title" style="color: #a6e22e; font-weight: bold; line-height: 26px;">outer</span>: &lt;<span class="hljs-title" style="color: #a6e22e; font-weight: bold; line-height: 26px;">globalLexicalEnvironment</span>&gt;
}
</span></code></pre>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 1em 4px;">在每次调用 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #333333;">count</code> 函数时，JavaScript 引擎都会为该函数创建一个新的词法环境，递增 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #333333;">counter</code> 变量并更新 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #333333;">getCounter</code> 函数的词法环境以反映更改。</p>
<h1 style="margin-top: 40px; margin-bottom: 20px; margin: 1.2em 0 1em; padding: 0; font-weight: 900; color: #773098; font-size: 25px;"><span>结论</span></h1>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 1em 4px;">通过上面的解释，相信你已经完全掌握了闭包。闭包是每个 JavaScript 开发人员都应该理解的 JavaScript 基本概念。熟悉这些概念将帮助您成为一个更有效，更好的 JavaScript 开发人员。</p>
<h1 style="margin-top: 40px; margin-bottom: 20px; margin: 1.2em 0 1em; padding: 0; font-weight: 900; color: #773098; font-size: 25px;"><span>最后</span></h1>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 1em 4px;">往期精彩：</p>
<ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500; margin: 10px 0;"><a href="https://mp.weixin.qq.com/s?__biz=MzU3MzcxMzg2Mw==&amp;mid=2247483918&amp;idx=1&amp;sn=49cb36e7fcab1b99662c94a4e2bca8ab&amp;chksm=fd3c3ea6ca4bb7b072178251a0984aca870b580a7b48376848a755d4635f4a68b9b7f1ac263e&amp;token=558341442&amp;lang=zh_CN#rd" style="text-decoration: none; word-wrap: break-word; font-weight: bold; color: #773098; border-bottom: 1px solid #773098;">前端面试必会 | 一文读懂 JavaScript 中的作用域和作用域链</a></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500; margin: 10px 0;"><a href="https://mp.weixin.qq.com/s?__biz=MzU3MzcxMzg2Mw==&amp;mid=2247483911&amp;idx=1&amp;sn=2922e6dc26a8aed4ec733c5ec0a24696&amp;chksm=fd3c3eafca4bb7b9cf15b43f3abedc270f6e18a0942364448a42862766c1bde7c42eb0cc61b9&amp;token=1392282839&amp;lang=zh_CN#rd" style="text-decoration: none; word-wrap: break-word; font-weight: bold; color: #773098; border-bottom: 1px solid #773098;">前端面试必会 | 理解 JavaScript 中的执行上下文</a></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500; margin: 10px 0;"><a href="https://mp.weixin.qq.com/s?__biz=MzU3MzcxMzg2Mw==&amp;mid=2247483904&amp;idx=1&amp;sn=856723984d94268ad80acc1b187c2de3&amp;chksm=fd3c3ea8ca4bb7be622635bb9ab75141174a1c9acee2c965a9e9abbed9cbb698a1697aae0bcf&amp;token=1392282839&amp;lang=zh_CN#rd" style="text-decoration: none; word-wrap: break-word; font-weight: bold; color: #773098; border-bottom: 1px solid #773098;">IntersectionObserver 和懒加载</a></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500; margin: 10px 0;"><a href="https://mp.weixin.qq.com/s?__biz=MzU3MzcxMzg2Mw==&amp;mid=2247483899&amp;idx=1&amp;sn=7c30a7f988b849dcf78c53d31047b53c&amp;chksm=fd3c3d53ca4bb445fb0f2daef575e692ad02de4b15d605577d05261ba626283cb6ca2b6acdcd&amp;token=1392282839&amp;lang=zh_CN#rd" style="text-decoration: none; word-wrap: break-word; font-weight: bold; color: #773098; border-bottom: 1px solid #773098;">初探浏览器渲染原理</a></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500; margin: 10px 0;"><a href="https://mp.weixin.qq.com/s?__biz=MzU3MzcxMzg2Mw==&amp;mid=2247483894&amp;idx=1&amp;sn=7464988cafe35295f7b078c257b3156e&amp;chksm=fd3c3d5eca4bb4481fd41a719a8b2f05ac2882a73a8c71fd2cfe294f9b7495d76133de3a1c25&amp;token=1392282839&amp;lang=zh_CN#rd" style="text-decoration: none; word-wrap: break-word; font-weight: bold; color: #773098; border-bottom: 1px solid #773098;">CSS 盒模型、布局和包含块</a></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500; margin: 10px 0;"><a href="https://mp.weixin.qq.com/s?__biz=MzU3MzcxMzg2Mw==&amp;mid=2247483890&amp;idx=1&amp;sn=3542cdb5682055766ca5d13cf87a231f&amp;chksm=fd3c3d5aca4bb44ca661d2fe59734d789b6d1f1750041113edce94dc544df0ce321809b0a70c&amp;token=1392282839&amp;lang=zh_CN#rd" style="text-decoration: none; word-wrap: break-word; font-weight: bold; color: #773098; border-bottom: 1px solid #773098;">详细解读 CSS 选择器优先级</a></section></li></ul>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 1em 4px;">关注公众号可以看更多哦。</p>
<figure style="margin: 0; margin-top: 10px; margin-bottom: 10px;"><img src="https://qiniu1.lxfriday.xyz/blog/image_20191209232941.png" alt="公众号" style="display: block; margin: 0 auto; width: 100%;"><figcaption style="margin-top: 5px; text-align: center; color: #888; font-size: 14px;">公众号</figcaption></figure>
</section>
